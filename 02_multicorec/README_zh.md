教程 02 - 多核 C 程序
===================

现在让我们来尝试一些更复杂的事情. 复杂意味着我们不再让 CPU 停留在第一个教程中的那种情况, 这次我们让其中一个核心从 C 程序停止. 

Start
-----

现在我们必须区分各个内核. 为此, 我们读取 *mpidr_el1* 系统寄存器. 如果不为 0, 我们继续先前的死循环, 如果为 0, 我们将调用一个 C 函数. 但是为此, 我们需要一个适当的堆栈, 并在调用指令之前将内存中的 bss 段清零. 我已经在汇编程序中添加了一些额外的代码来做这件事情. 为了避免 C 代码返回 (不应该), 我们仍然跳转到像其他内核一样执行的死循环. 

Makefile
---------

它变得更麻烦了一些. 我添加了编译 C 源码的命令, 但以一种通用的方式. 从现在起, 我们可以在任意教程中使用同样的 Makefile文件, 而不管源码中有多少个 C文件, 并且我将不再讨论 Makefile 文件.

Linker 脚本
-----------

同样地, 由于 C 程序需要数据和 bss 段, Linker 脚本也变得更复杂. 我添加了一段计算 bss 大小的代码, 这使得我们可以从汇编程序中引用它, 而不显得麻烦. 

以汇编代码开始文本段非常重要, 因为我们我们在它之前设置了堆栈, 所以 KEEP() 这样写. 这样, 我们的加载地址是 0x80000, 和 `_start` 标签和栈顶相同.

Main
-----

这是我们的第一个 C 代码. 仍然只是空循环.